//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     RTGen (CppGenerator v5.0.0) on 20.07.2024 00:55:25.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma once
#include <coretypes/coretypes.h>
#include "cqdaq/data_rule.h"
#include <coretypes/objectptr.h>
#include <coretypes/dict_ptr.h>
#include <coretypes/string_ptr.h>




BEGIN_NAMESPACE_CQDAQ


class DataRulePtr;



END_NAMESPACE_CQDAQ

BEGIN_NAMESPACE_CQDAQ

template <>
struct InterfaceToSmartPtr<daq::IDataRule>
{
    using SmartPtr = daq::DataRulePtr;
};


END_NAMESPACE_CQDAQ

BEGIN_NAMESPACE_CQDAQ



/*!
 * @ingroup cqdaq_data_descriptor
 * @addtogroup cqdaq_data_rule Data rule
 * @{

 */


/*!
 * @brief Enumeration of available Data rule types

 */


/*!
 * @brief Rule that defines how a signal value is calculated from an implicit initialization
 * value when the rule type is not `Explicit`.

 * Data rule objects implement the Struct methods internally and are Core type `ctStruct`.
 * @subsection data_rule_explicit Explicit rule
 * When the rule type of the Data rule is set to `Explicit`, the values passed through the signal path, described by
 * the Value descriptor are stored in packet buffers.
 * The Explicit rule can have 2 optional parameters:
 * - `minExpectedDelta`: Specifies the minimum difference in value between two subsequent samples
 * - `maxExpectedDelta`: Specifies the maximum difference in value between two subsequent samples
 * These are mostly used for domain signals to specify the expected rate of a signal, or the expected timeout of a signal.
 * The delta parameters should be configured to match the deltas in terms of the raw signal values (before scaling/resolution
 * are applied).
 * An explicit rule must have either both or none of these parameters. To use only one, the other must be set to 0.
 * @subsection data_rule_implicit Implicit rule
 * When the rule type of the Data rule is not `Explicit`, the buffers of packets are empty. The values must instead be
 * calculated via the Implicit value found in the packet buffers in conjunction with the parameters of the rule. Each
 * implicit rule type specifies its own required set of parameters.
 * @subsubsection data_rule_linear Linear rule
 * The parameters include a `delta` and `start` integer members. The values are calculated according to the following
 * equation: <em>packetOffset + sampleIndex * delta + start</em>.
 * @subsubsection data_rule_linear Constant rule
 * The parameters contain a `constant` number member. The value described by the constant rule is always equal to the
 * constant.
 */

class DataRulePtr : public daq::ObjectPtr<IDataRule>
{
public:
    using daq::ObjectPtr<IDataRule>::ObjectPtr;
    //using daq::ObjectPtr<IDataRule>::operator=;



    DataRulePtr()
        : daq::ObjectPtr<IDataRule>()

    {
    }

    DataRulePtr(daq::ObjectPtr<IDataRule>&& ptr)
        : daq::ObjectPtr<IDataRule>(std::move(ptr))

    {
    }

    DataRulePtr(const daq::ObjectPtr<IDataRule>& ptr)
        : daq::ObjectPtr<IDataRule>(ptr)

    {
    }

    DataRulePtr(const DataRulePtr& other)
        : daq::ObjectPtr<IDataRule>(other)

    {
    }

    DataRulePtr(DataRulePtr&& other) noexcept
        : daq::ObjectPtr<IDataRule>(std::move(other))

    {
    }
    
    DataRulePtr& operator=(const DataRulePtr& other)
    {
        if (this == &other)
            return *this;

        daq::ObjectPtr<IDataRule>::operator =(other);


        return *this;
    }

    DataRulePtr& operator=(DataRulePtr&& other) noexcept
    {
        if (this == std::addressof(other))
        {
            return *this;
        }


        daq::ObjectPtr<IDataRule>::operator =(std::move(other));

        return *this;
    }


    /*!
     * @brief Gets the type of the data rule.

     * @returns The type of the data rule.
     */
    daq::DataRuleType getType() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::DataRuleType type;
        auto errCode = this->object->getType(&type);
        daq::checkErrorInfo(errCode);

        return type;
    }


    /*!
     * @brief Gets a dictionary of string-object key-value pairs representing the parameters used to evaluate the rule.

     * @returns The dictionary containing the rule parameter members.
     */
    daq::DictPtr<daq::IString, daq::IBaseObject> getParameters() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::DictPtr<daq::IString, daq::IBaseObject> parameters;
        auto errCode = this->object->getParameters(&parameters);
        daq::checkErrorInfo(errCode);

        return parameters;
    }

#if __has_include(<cqdaq/data_rule_ptr.custom.h>)
    #include <cqdaq/data_rule_ptr.custom.h>
#endif
};

/*!
 * @}
 */


/*!
 * @ingroup cqdaq_data_rule
 * @addtogroup cqdaq_data_rule_factories Factories
 * @{

 */


/*!
 * @}
 */


END_NAMESPACE_CQDAQ
