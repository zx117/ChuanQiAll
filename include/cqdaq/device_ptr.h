//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     RTGen (CppGenerator v5.0.0) on 24.10.2024 06:57:03.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma once
#include <coretypes/coretypes.h>
#include "cqdaq/device.h"
#include <cqdaq/folder_ptr.h>
#include <cqdaq/device_info_ptr.h>
#include <cqdaq/device_domain_ptr.h>
#include <coretypes/list_ptr.h>
#include <cqdaq/component_ptr.h>
#include <cqdaq/signal_ptr.h>
#include <cqdaq/search_filter_ptr.h>
#include <cqdaq/channel_ptr.h>
#include <coretypes/dict_ptr.h>
#include <coretypes/string_ptr.h>
#include <cqdaq/device_type_ptr.h>
#include <coreobjects/property_object.h>
#include <cqdaq/function_block_ptr.h>
#include <cqdaq/function_block_type_ptr.h>
#include <cqdaq/data_center_config_ptr.h>




BEGIN_NAMESPACE_CQDAQ

template <typename InterfaceType = daq::IDevice>
class GenericDevicePtr;

using DevicePtr = daq::GenericDevicePtr<>;

END_NAMESPACE_CQDAQ

BEGIN_NAMESPACE_CQDAQ

template <>
struct InterfaceToSmartPtr<daq::IDevice>
{
    using SmartPtr = daq::GenericDevicePtr<daq::IDevice>;
};


END_NAMESPACE_CQDAQ

BEGIN_NAMESPACE_CQDAQ



/*!
 * @ingroup cqdaq_devices
 * @addtogroup cqdaq_device Device
 * @{

 */


/*!
 * @brief Represents an cqDAQ device. The device contains a list of signals and physical channels.
 * Some devices support adding function blocks, or connecting to devices. The list of available
 * function blocks/devices can be obtained via the `getAvailable` functions, and added
 * via the `add` functions.

 * Devices can be split up into three different types, with each devices supporting one or more:
 * 1. Physical devices
 * Physical devices provide access to physical channels. They measure real-world data and send
 * it via packets through output signals of channels. The list of channels can be obtained via
 * `getChannels` as a flat list.
 * 2. Client devices
 * Client devices can connect to other devices via their supported connection protocol. cqDAQ
 * natively supports connecting to TMS devices via its cqDAQ OpcUa Client Module. A list of available
 * devices a client device can connect to can be obtained via `getAvailableDevices`. The
 * `addDevice` is used to connect to/add a device.
 * 3. Function block devices
 * Function block devices provide a dictionary of available function block types that can be added to them
 * and configured. The calculation of function blocks is done on the device itself. The dictionary
 * of available function block types can be obtained via `getAvailableFunctionBlockTypes`. They
 * can then be added via `addFunctionBlock`.
 * All devices also provide access to their Device information, containing metadata such as the
 * device's serial number, location... They can also be queried for their current domain values
 * (time) through its device domain.
 * As each device is a property object, a device has access to all Property object methods, allowing
 * each device to expose a list of custom properties such as sample rate, scaling factor and many
 * others. By default, cqDAQ devices have the UserName and Location string Properties.
 */
template <typename InterfaceType>
class GenericDevicePtr : public GenericFolderPtr<InterfaceType>
{
public:
    using GenericFolderPtr<InterfaceType>::GenericFolderPtr;
    //using GenericFolderPtr<InterfaceType>::operator=;



    GenericDevicePtr()
        : GenericFolderPtr<InterfaceType>()

    {
    }

    GenericDevicePtr(daq::ObjectPtr<InterfaceType>&& ptr)
        : GenericFolderPtr<InterfaceType>(std::move(ptr))

    {
    }

    GenericDevicePtr(const daq::ObjectPtr<InterfaceType>& ptr)
        : GenericFolderPtr<InterfaceType>(ptr)

    {
    }

    GenericDevicePtr(const DevicePtr& other)
        : GenericFolderPtr<InterfaceType>(other)

    {
    }

    GenericDevicePtr(DevicePtr&& other) noexcept
        : GenericFolderPtr<InterfaceType>(std::move(other))

    {
    }
    
    GenericDevicePtr& operator=(const DevicePtr& other)
    {
        if (this == &other)
            return *this;

        GenericFolderPtr<InterfaceType>::operator =(other);


        return *this;
    }

    GenericDevicePtr& operator=(DevicePtr&& other) noexcept
    {
        if (this == std::addressof(other))
        {
            return *this;
        }


        GenericFolderPtr<InterfaceType>::operator =(std::move(other));

        return *this;
    }


    /*!
     * @brief Gets the device info. It contains data about the device such as the device's
     * serial number, location, and connection string.

     * @returns The device info.
     */
    daq::DeviceInfoPtr getInfo() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::DeviceInfoPtr info;
        auto errCode = this->object->getInfo(&info);
        daq::checkErrorInfo(errCode);

        return info;
    }


    /*!
     * @brief Gets the device's domain data. It allows for querying the device for its
     * domain (time) values.

     * @returns The device domain.
     */
    daq::DeviceDomainPtr getDomain() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::DeviceDomainPtr domain;
        auto errCode = this->object->getDomain(&domain);
        daq::checkErrorInfo(errCode);

        return domain;
    }


    /*!
     * @brief Gets a folder containing channels. 

     * @returns The folder that contains channels.
     * The InputsOutputs folder can contain other folders that themselves contain channels.
     */
    daq::GenericFolderPtr<daq::IFolder> getInputsOutputsFolder() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::GenericFolderPtr<daq::IFolder> inputsOutputsFolder;
        auto errCode = this->object->getInputsOutputsFolder(&inputsOutputsFolder);
        daq::checkErrorInfo(errCode);

        return inputsOutputsFolder;
    }


    /*!
     * @brief Gets a list of all components/folders in a device that are not titled 'io', 'sig', 'dev' or 'fb'

     * @returns The list of custom components.
     */
    daq::ListPtr<daq::IComponent> getCustomComponents() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::ListPtr<daq::IComponent> customComponents;
        auto errCode = this->object->getCustomComponents(&customComponents);
        daq::checkErrorInfo(errCode);

        return customComponents;
    }


    /*!
     * @brief Gets a list of the device's signals.

     * @param searchFilter Provides an optional filter that filters out unwanted components and allows for recursion.
     * @returns The flat list of signals.
     * If searchFilter is not provided, the returned list contains only visible signals and does not include those of
     * child function blocks, devices, or channels.
     * Device signals are most often domain signals shared by other signals that belong to channels and/or function blocks.
     */
    daq::ListPtr<daq::ISignal> getSignals(const daq::SearchFilterPtr& searchFilter = nullptr) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::ListPtr<daq::ISignal> signals;
        auto errCode = this->object->getSignals(&signals, searchFilter);
        daq::checkErrorInfo(errCode);

        return signals;
    }


    /*!
     * @brief Gets a list of the signals that belong to the device.

     * @param searchFilter Provides an optional filter that filters out unwanted components and allows for recursion.
     * @returns The flat list of signals.
     * The list includes visible signals that belong to visible channels, function blocks, or sub devices
     * of the device.
     */
    daq::ListPtr<daq::ISignal> getSignalsRecursive(const daq::SearchFilterPtr& searchFilter = nullptr) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::ListPtr<daq::ISignal> signals;
        auto errCode = this->object->getSignalsRecursive(&signals, searchFilter);
        daq::checkErrorInfo(errCode);

        return signals;
    }


    /*!
     * @brief Gets a flat list of the device's physical channels.

     * @param searchFilter Provides an optional filter that filters out unwanted components and allows for recursion.
     * @returns The flat list of channels.
     * If searchFilter is not provided, the returned list contains only visible channels and does not include those of
     * child devices.
     */
    daq::ListPtr<daq::IChannel> getChannels(const daq::SearchFilterPtr& searchFilter = nullptr) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::ListPtr<daq::IChannel> channels;
        auto errCode = this->object->getChannels(&channels, searchFilter);
        daq::checkErrorInfo(errCode);

        return channels;
    }


    /*!
     * @brief Gets a flat list of the device's physical channels. Also finds all visible channels of visible child devices

     * @param searchFilter Provides an optional filter that filters out unwanted components and allows for recursion.
     * @returns The flat list of channels.
     */
    daq::ListPtr<daq::IChannel> getChannelsRecursive(const daq::SearchFilterPtr& searchFilter = nullptr) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::ListPtr<daq::IChannel> channels;
        auto errCode = this->object->getChannelsRecursive(&channels, searchFilter);
        daq::checkErrorInfo(errCode);

        return channels;
    }


    /*!
     * @brief Gets a list of child devices that the device is connected to.

     * @param searchFilter Provides an optional filter that filters out unwanted components and allows for recursion.
     * @returns The list of devices.
     * If searchFilter is not provided, the returned list contains only visible devices and does not include those of
     * child devices.
     */
    daq::ListPtr<daq::IDevice> getDevices(const daq::SearchFilterPtr& searchFilter = nullptr) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::ListPtr<daq::IDevice> devices;
        auto errCode = this->object->getDevices(&devices, searchFilter);
        daq::checkErrorInfo(errCode);

        return devices;
    }


    /*!
     * @brief Gets a list of available devices, containing their Device Info.

     * @returns The list of available devices.
     * The getAvailableDevices most often runs a discovery client, querying for available devices that
     * a device module can connect to. The replies are formed into Device Info objects and inserted to the
     * list of available devices.
     */
    daq::ListPtr<daq::IDeviceInfo> getAvailableDevices() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::ListPtr<daq::IDeviceInfo> availableDevices;
        auto errCode = this->object->getAvailableDevices(&availableDevices);
        daq::checkErrorInfo(errCode);

        return availableDevices;
    }


    /*!
     * @brief Get a dictionary of available device types as <IString, IDeviceType> pairs

     * @returns The dictionary of available device types.
     */
    daq::DictPtr<daq::IString, daq::IDeviceType> getAvailableDeviceTypes() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::DictPtr<daq::IString, daq::IDeviceType> deviceTypes;
        auto errCode = this->object->getAvailableDeviceTypes(&deviceTypes);
        daq::checkErrorInfo(errCode);

        return deviceTypes;
    }


    /*!
     * @brief Connects to a device at the given connection string and returns it.

     * @returns The added device.
     * @param connectionString The connection string containing the address of the device. In example an
     * IPv4/IPv6 address. The connection string can be found in the Device Info objects returned by
     * `getAvailableDevices`.
     * @param config A config object to configure a client device. This object can contain properties like max sample rate,
     * port to use for 3rd party communication, number of channels to generate, or other device specific settings. Can be
     * created from its corresponding Device type object. In case of a null value, it will use the default configuration.
     */
    daq::GenericDevicePtr<daq::IDevice> addDevice(const daq::StringPtr& connectionString, const daq::PropertyObjectPtr& config = nullptr) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::GenericDevicePtr<daq::IDevice> device;
        auto errCode = this->object->addDevice(&device, connectionString, config);
        daq::checkErrorInfo(errCode);

        return device;
    }


    /*!
     * @brief Disconnects from the device provided as argument and removes it from the internal list of devices.

     * @param device The device to be removed.
     */
    void removeDevice(const daq::GenericDevicePtr<daq::IDevice>& device) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        auto errCode = this->object->removeDevice(device);
        daq::checkErrorInfo(errCode);
    }


    /*!
     * @brief Gets the list of added function blocks.

     * @param searchFilter Provides an optional filter that filters out unwanted components and allows for recursion.
     * @returns The list of added function blocks.
     * If searchFilter is not provided, the returned list contains only visible function blocks and does not include those of
     * child function blocks, devices, or channels.
     */
    daq::ListPtr<daq::IFunctionBlock> getFunctionBlocks(const daq::SearchFilterPtr& searchFilter = nullptr) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::ListPtr<daq::IFunctionBlock> functionBlocks;
        auto errCode = this->object->getFunctionBlocks(&functionBlocks, searchFilter);
        daq::checkErrorInfo(errCode);

        return functionBlocks;
    }


    /*!
     * @brief Gets all function block types that are supported by the device, containing their description.

     * @returns A dictionary of available function block types.
     */
    daq::DictPtr<daq::IString, daq::IFunctionBlockType> getAvailableFunctionBlockTypes() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::DictPtr<daq::IString, daq::IFunctionBlockType> functionBlockTypes;
        auto errCode = this->object->getAvailableFunctionBlockTypes(&functionBlockTypes);
        daq::checkErrorInfo(errCode);

        return functionBlockTypes;
    }


    /*!
     * @brief Creates and adds a function block to the device with the provided unique ID and returns it.

     * @returns The added function block.
     * @param typeId The unique ID of the function block. Can be obtained from its corresponding Function Block Info
     * object.
     * @param config A config object to configure a function block with custom settings specific to that function block type.
     */
    daq::FunctionBlockPtr addFunctionBlock(const daq::StringPtr& typeId, const daq::PropertyObjectPtr& config = nullptr) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::FunctionBlockPtr functionBlock;
        auto errCode = this->object->addFunctionBlock(&functionBlock, typeId, config);
        daq::checkErrorInfo(errCode);

        return functionBlock;
    }


    /*!
     * @brief Removes the function block provided as argument, disconnecting its signals and input ports.

     * @param functionBlock The function block to be removed.
     */
    void removeFunctionBlock(const daq::FunctionBlockPtr& functionBlock) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        auto errCode = this->object->removeFunctionBlock(functionBlock);
        daq::checkErrorInfo(errCode);
    }


    /*!
     * @brief Saves the configuration of the device to string.

     * @returns Serialized configuration of the device.
     */
    daq::StringPtr saveConfiguration() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::StringPtr configuration;
        auto errCode = this->object->saveConfiguration(&configuration);
        daq::checkErrorInfo(errCode);

        return configuration;
    }


    /*!
     * @brief Loads the configuration of the device from string.

     * @param configuration Serialized configuration of the device.
     */
    void loadConfiguration(const daq::StringPtr& configuration) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        auto errCode = this->object->loadConfiguration(configuration);
        daq::checkErrorInfo(errCode);
    }


    /*!
     * @brief Gets the number of ticks passed since the device's absolute origin.

     * @returns The number of ticks.
     * To scale the ticks into a domain unit, the Device's Domain should be used.
     */
    daq::UInt getTicksSinceOrigin() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::UInt ticks;
        auto errCode = this->object->getTicksSinceOrigin(&ticks);
        daq::checkErrorInfo(errCode);

        return ticks;
    }


    
    void setDataCenter(const daq::DataCenterConfigPtr& dcConfig) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        auto errCode = this->object->setDataCenter(dcConfig);
        daq::checkErrorInfo(errCode);
    }

#if __has_include(<cqdaq/device_ptr.custom.h>)
    #include <cqdaq/device_ptr.custom.h>
#endif
};

/*!
 * @}
 */


END_NAMESPACE_CQDAQ
