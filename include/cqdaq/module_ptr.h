//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     RTGen (CppGenerator v5.0.0) on 20.07.2024 00:55:56.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma once
#include <coretypes/coretypes.h>
#include "cqdaq/module.h"
#include <coretypes/objectptr.h>
#include <coretypes/version_info_ptr.h>
#include <coretypes/string_ptr.h>
#include <coretypes/list_ptr.h>
#include <cqdaq/device_info_ptr.h>
#include <coretypes/dict_ptr.h>
#include <cqdaq/device_type_ptr.h>
#include <coreobjects/property_object_ptr.h>
#include <cqdaq/device_ptr.h>
#include <cqdaq/component_ptr.h>
#include <cqdaq/function_block_type_ptr.h>
#include <cqdaq/function_block_ptr.h>
#include <cqdaq/server_type_ptr.h>
#include <cqdaq/server_ptr.h>
#include <cqdaq/streaming_ptr.h>




BEGIN_NAMESPACE_CQDAQ


class ModulePtr;



END_NAMESPACE_CQDAQ

BEGIN_NAMESPACE_CQDAQ

template <>
struct InterfaceToSmartPtr<daq::IModule>
{
    using SmartPtr = daq::ModulePtr;
};


END_NAMESPACE_CQDAQ

BEGIN_NAMESPACE_CQDAQ



/*!
 * @ingroup cqdaq_modules
 * @addtogroup cqdaq_module Module
 * @{

 */


/*!
 *  @brief A module is an object that provides device and function block factories.
 *  The object is usually implemented in an external dynamic link / shared library.
 *  IModuleManager is responsible for loading all modules.

 */

class ModulePtr : public daq::ObjectPtr<IModule>
{
public:
    using daq::ObjectPtr<IModule>::ObjectPtr;
    //using daq::ObjectPtr<IModule>::operator=;



    ModulePtr()
        : daq::ObjectPtr<IModule>()

    {
    }

    ModulePtr(daq::ObjectPtr<IModule>&& ptr)
        : daq::ObjectPtr<IModule>(std::move(ptr))

    {
    }

    ModulePtr(const daq::ObjectPtr<IModule>& ptr)
        : daq::ObjectPtr<IModule>(ptr)

    {
    }

    ModulePtr(const ModulePtr& other)
        : daq::ObjectPtr<IModule>(other)

    {
    }

    ModulePtr(ModulePtr&& other) noexcept
        : daq::ObjectPtr<IModule>(std::move(other))

    {
    }
    
    ModulePtr& operator=(const ModulePtr& other)
    {
        if (this == &other)
            return *this;

        daq::ObjectPtr<IModule>::operator =(other);


        return *this;
    }

    ModulePtr& operator=(ModulePtr&& other) noexcept
    {
        if (this == std::addressof(other))
        {
            return *this;
        }


        daq::ObjectPtr<IModule>::operator =(std::move(other));

        return *this;
    }


    /*!
     * @brief Retrieves the module version information.

     * @returns The semantic version information.
     */
    daq::VersionInfoPtr getVersionInfo() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::VersionInfoPtr version;
        auto errCode = this->object->getVersionInfo(&version);
        daq::checkErrorInfo(errCode);

        return version;
    }


    /*!
     * @brief Gets the module name.

     * @returns The module name.
     */
    daq::StringPtr getName() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::StringPtr name;
        auto errCode = this->object->getName(&name);
        daq::checkErrorInfo(errCode);

        return name;
    }


    /*!
     * @brief Gets the module id.

     * @returns The module id.
     */
    daq::StringPtr getId() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::StringPtr id;
        auto errCode = this->object->getId(&id);
        daq::checkErrorInfo(errCode);

        return id;
    }


    /*!
     * @brief Returns a list of known devices info.
     * The implementation can start discovery in background and only return the results in this function.

     * @returns The list of known devices information.
     */
    daq::ListPtr<daq::IDeviceInfo> getAvailableDevices() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::ListPtr<daq::IDeviceInfo> availableDevices;
        auto errCode = this->object->getAvailableDevices(&availableDevices);
        daq::checkErrorInfo(errCode);

        return availableDevices;
    }


    /*!
     * @brief Returns a dictionary of known and available device types this module can create.

     * @returns The dictionary of known device types.
     */
    daq::DictPtr<daq::IString, daq::IDeviceType> getAvailableDeviceTypes() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::DictPtr<daq::IString, daq::IDeviceType> deviceTypes;
        auto errCode = this->object->getAvailableDeviceTypes(&deviceTypes);
        daq::checkErrorInfo(errCode);

        return deviceTypes;
    }


    /*!
     * @brief Checks if connection string can be used to connect to devices supported by this module and if the
     * configuration object provided to this module is valid.

     * @returns Whether this module supports the @p connectionString and @p config.
     * @param connectionString Typically a connection string usually has a well known prefix, such as `opc.tcp//`.
     * Connection strings could simply be devices such as `obsidian` when cqDAQ SDK is running on DAQ device hardware.
     * @param config A configuration object that contains connection parameters in the form of key-value pairs. The configuration
     * is used and applied when connecting to a device. This method check if provided config object is valid.
     */
    daq::Bool acceptsConnectionParameters(const daq::StringPtr& connectionString, const daq::PropertyObjectPtr& config = nullptr) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::Bool accepted;
        auto errCode = this->object->acceptsConnectionParameters(&accepted, connectionString, config);
        daq::checkErrorInfo(errCode);

        return accepted;
    }


    /*!
     * @brief Creates a device object that can communicate with the device described in the specified connection string.
     * The device object is not automatically added as a sub-device of the caller, but only returned by reference.

     * @returns The device object created to communicate with and control the device.
     * @param connectionString Describes the connection info of the device to connect to.
     * @param parent The parent component/device to which the device attaches.
     * @param config A configuration object that contains parameters used to configure a device in the form of key-value pairs.
     */
    daq::DevicePtr createDevice(const daq::StringPtr& connectionString, const daq::ComponentPtr& parent, const daq::PropertyObjectPtr& config = nullptr) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::DevicePtr device;
        auto errCode = this->object->createDevice(&device, connectionString, parent, config);
        daq::checkErrorInfo(errCode);

        return device;
    }


    /*!
     * @brief Returns a dictionary of known and available function block types this module can create.

     * @returns The dictionary of known function block types.
     */
    daq::DictPtr<daq::IString, daq::IFunctionBlockType> getAvailableFunctionBlockTypes() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::DictPtr<daq::IString, daq::IFunctionBlockType> functionBlockTypes;
        auto errCode = this->object->getAvailableFunctionBlockTypes(&functionBlockTypes);
        daq::checkErrorInfo(errCode);

        return functionBlockTypes;
    }


    /*!
     * @brief Creates and returns a function block with the specified id.
     * The function block is not automatically added to the FB list of the caller.

     * @param id The id of the function block to create. Ids can be retrieved by calling `getAvailableFunctionBlockTypes()`.
     * @param parent The parent component/device to which the device attaches.
     * @param localId The local id of the function block.
     * @param config Function block configuration. In case of a null value, implementation should use default configuration.
     * @returns The created function block.
     */
    daq::FunctionBlockPtr createFunctionBlock(const daq::StringPtr& id, const daq::ComponentPtr& parent, const daq::StringPtr& localId, const daq::PropertyObjectPtr& config = nullptr) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::FunctionBlockPtr functionBlock;
        auto errCode = this->object->createFunctionBlock(&functionBlock, id, parent, localId, config);
        daq::checkErrorInfo(errCode);

        return functionBlock;
    }


    /*!
     * @brief Returns a dictionary of known and available servers types that this module can create.

     * @returns The dictionary of known server types.
     */
    daq::DictPtr<daq::IString, daq::IServerType> getAvailableServerTypes() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::DictPtr<daq::IString, daq::IServerType> serverTypes;
        auto errCode = this->object->getAvailableServerTypes(&serverTypes);
        daq::checkErrorInfo(errCode);

        return serverTypes;
    }


    /*!
     * @brief Creates and returns a server with the specified server type.
     * To prevent cyclic reference, we should not use the Instance instead of rootDevice.

     * @param serverTypeId The id of the server type to create. ServerType can be retrieved by calling `getAvailableServerTypes()`.
     * @param config Server configuration. In case of a null value, implementation should use default configuration.
     * @param rootDevice Root device.
     * @returns The created server.
     */
    daq::ServerPtr createServer(const daq::StringPtr& serverTypeId, const daq::DevicePtr& rootDevice, const daq::PropertyObjectPtr& config = nullptr) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::ServerPtr server;
        auto errCode = this->object->createServer(&server, serverTypeId, rootDevice, config);
        daq::checkErrorInfo(errCode);

        return server;
    }


    /*!
     * @brief Verifies whether the provided connection string or config object can be used to establish a streaming connection
     * supported by this module. If the connection string is not assigned, it checks if the config object
     * is valid and complete enough to generate a connection string.

     * @returns Whether this module supports the @p connectionString or @p config.
     * @param connectionString Typically a connection string usually has a well known prefix, such as `daq.lt//`.
     * @param config A configuration info object that contains streaming type ID and additional parameters.
     * The configuration info is used to generate a connection string if it is not present.
     */
    daq::Bool acceptsStreamingConnectionParameters(const daq::StringPtr& connectionString, const daq::PropertyObjectPtr& config = nullptr) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::Bool accepted;
        auto errCode = this->object->acceptsStreamingConnectionParameters(&accepted, connectionString, config);
        daq::checkErrorInfo(errCode);

        return accepted;
    }


    /*!
     * @brief Creates and returns a streaming object using the specified connection string or config info object.

     * @param connectionString Typically a connection string usually has a well known prefix, such as `daq.lt//`.
     * @param config Streaming configuration info.
     * @returns The created streaming object.
     */
    daq::StreamingPtr createStreaming(const daq::StringPtr& connectionString, const daq::PropertyObjectPtr& config) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::StreamingPtr streaming;
        auto errCode = this->object->createStreaming(&streaming, connectionString, config);
        daq::checkErrorInfo(errCode);

        return streaming;
    }

#if __has_include(<cqdaq/module_ptr.custom.h>)
    #include <cqdaq/module_ptr.custom.h>
#endif
};

/*!
 * @}
 */


END_NAMESPACE_CQDAQ
