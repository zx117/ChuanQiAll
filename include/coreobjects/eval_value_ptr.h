//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     RTGen (CppGenerator v5.0.0) on 20.07.2024 00:55:03.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma once
#include <coretypes/coretypes.h>
#include "coreobjects/eval_value.h"
#include <coretypes/objectptr.h>
#include <coretypes/string_ptr.h>
#include <coreobjects/property_object_ptr.h>
#include <coretypes/list_ptr.h>




BEGIN_NAMESPACE_CQDAQ


class EvalValuePtr;



END_NAMESPACE_CQDAQ

BEGIN_NAMESPACE_CQDAQ

template <>
struct InterfaceToSmartPtr<daq::IEvalValue>
{
    using SmartPtr = daq::EvalValuePtr;
};


END_NAMESPACE_CQDAQ

BEGIN_NAMESPACE_CQDAQ



/*!
 * @ingroup objects_property
 * @addtogroup objects_eval_value_obj EvalValue
 * @{

 */


/*!
 * @brief Dynamic expression evaluator

 * Provides dynamic evaluation of expressions. Expression is passed as an argument to a
 * factory function. Expression is evaluated at runtime when result value is requested.
 */

class EvalValuePtr : public daq::ObjectPtr<IEvalValue>
{
public:
    using daq::ObjectPtr<IEvalValue>::ObjectPtr;
    //using daq::ObjectPtr<IEvalValue>::operator=;



    EvalValuePtr()
        : daq::ObjectPtr<IEvalValue>()

    {
    }

    EvalValuePtr(daq::ObjectPtr<IEvalValue>&& ptr)
        : daq::ObjectPtr<IEvalValue>(std::move(ptr))

    {
    }

    EvalValuePtr(const daq::ObjectPtr<IEvalValue>& ptr)
        : daq::ObjectPtr<IEvalValue>(ptr)

    {
    }

    EvalValuePtr(const EvalValuePtr& other)
        : daq::ObjectPtr<IEvalValue>(other)

    {
    }

    EvalValuePtr(EvalValuePtr&& other) noexcept
        : daq::ObjectPtr<IEvalValue>(std::move(other))

    {
    }
    
    EvalValuePtr& operator=(const EvalValuePtr& other)
    {
        if (this == &other)
            return *this;

        daq::ObjectPtr<IEvalValue>::operator =(other);


        return *this;
    }

    EvalValuePtr& operator=(EvalValuePtr&& other) noexcept
    {
        if (this == std::addressof(other))
        {
            return *this;
        }


        daq::ObjectPtr<IEvalValue>::operator =(std::move(other));

        return *this;
    }


    /*!
     * @brief Gets the expression.

     * @returns The expression.
     * Expression is passed as a parameter to the factory function.
     */
    daq::StringPtr getEval() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::StringPtr eval;
        auto errCode = this->object->getEval(&eval);
        daq::checkErrorInfo(errCode);

        return eval;
    }


    /*!
     * @brief Gets the result of the expression.

     * @returns The result of the expression.
     * @throws CalcFailedException when calculation failed.
     * @throws CqdaqErrException when reference resolution failed
     * @throws ParseFailedException when expression parsing failed
     * When this method is called for the first time, the object will trigger
     * execution and return result.
     */
    daq::BaseObjectPtr getResult() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::BaseObjectPtr obj;
        auto errCode = this->object->getResult(&obj);
        daq::checkErrorInfo(errCode);

        return obj;
    }


    /*!
     * @brief Clones the object and attaches an owner.

     * @param owner The owner to attach to the cloned eval value.
     * @returns The cloned object.
     * When the expression contains reference to some property object, then the expression cannot be
     * evaluated unless an owner is attached to eval value. However, the object can be cloned with the
     * specified owner attached. The client can then evaluate the cloned object.
     */
    daq::EvalValuePtr cloneWithOwner(const daq::PropertyObjectPtr& owner) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::EvalValuePtr clonedValue;
        auto errCode = this->object->cloneWithOwner(owner, &clonedValue);
        daq::checkErrorInfo(errCode);

        return clonedValue;
    }


    /*!
     * @brief Returns the parse error code.

     * When an eval value object is created, the expression is passed as an argument to the factory
     * function. Parsing of the expression can fail, but the factory function will always succeed. Use this
     * function to check if the parsing of the expression succeeded without evaluating the expression.
     */
    void getParseErrorCode() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        auto errCode = this->object->getParseErrorCode();
        daq::checkErrorInfo(errCode);
    }


    /*!
     * @brief Returns the names of all properties referenced by the eval value.

     * @returns The names of referenced properties.
     * Referenced properties are all occurrences matching the '"%" propref' pattern in the evaluation string.
     */
    daq::ListPtr<daq::IString> getPropertyReferences() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::ListPtr<daq::IString> propertyReferences;
        auto errCode = this->object->getPropertyReferences(&propertyReferences);
        daq::checkErrorInfo(errCode);

        return propertyReferences;
    }

#if __has_include(<coreobjects/eval_value_ptr.custom.h>)
    #include <coreobjects/eval_value_ptr.custom.h>
#endif
};

END_NAMESPACE_CQDAQ
