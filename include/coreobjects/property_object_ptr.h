//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     RTGen (CppGenerator v5.0.0) on 20.07.2024 00:55:02.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma once
#include <coretypes/coretypes.h>
#include "coreobjects/property_object.h"
#include <coretypes/objectptr.h>
#include <coretypes/string_ptr.h>
#include <coreobjects/property_ptr.h>
#include <coretypes/event_ptr.h>
#include <coreobjects/property_value_event_args_ptr.h>
#include <coretypes/list_ptr.h>
#include <coreobjects/end_update_event_args_ptr.h>




BEGIN_NAMESPACE_CQDAQ

template <typename InterfaceType = daq::IPropertyObject>
class GenericPropertyObjectPtr;

using PropertyObjectPtr = daq::GenericPropertyObjectPtr<>;

END_NAMESPACE_CQDAQ

BEGIN_NAMESPACE_CQDAQ

template <>
struct InterfaceToSmartPtr<daq::IPropertyObject>
{
    using SmartPtr = daq::GenericPropertyObjectPtr<daq::IPropertyObject>;
};


END_NAMESPACE_CQDAQ

BEGIN_NAMESPACE_CQDAQ



/*!
 * @ingroup objects_property_object
 * @addtogroup objects_property_object_obj PropertyObject
 * @{

 */


/*!
 * @brief A container of Properties and their corresponding Property values.

 * The Property object acts as a container of properties that can be inherited from a specified Property object class,
 * or added to the Property object after its creation. The property names must be unique within any given Property object,
 * as no duplicates are allowed.
 * The Property object class name is specified when constructing the Property object, and the class itself is obtained from
 * the Type manager, which, at that point, must already contain a class with the specified name.
 * Each Property defines a set of metadata, specifying what value type it represents, as well as additional information that
 * is used when displaying an user interface, such as whether or not a Property is visible, or read-only. The Property can
 * also limit the set of valid values by specifying a minimum/maximum value, or validation/coercion expressions.
 * In addition to properties, a Property object holds a dictionary of Property values, where the key is a Property's name,
 * and the value is the current Property value. When setting the value of a property, the value is written into the said dictionary.
 * Correspondingly, when reading the value of a property, it is read from the dictionary as well. If the value is not present in
 * the dictionary, the default value of the Property is read instead.
 * Property values must match the Value, Item, and Key type of the corresponding Property. If the Property expects an integer type,
 * only objects of which core type is equal to ctInt can be written to said Property. The Item type represents the type of items
 * expected in lists and dictionaries (when the value type is ctList or ctDict), while the Key type represents the type of keys
 * expected in a dictionary (when the value type is ctDict). Notable, when the Property expects object type values, only other
 * base Property objects can be written to said property. Any classes that inherit the Property object class are not valid Property
 * values.
 * Property objects can be frozen. When frozen, their set of Properties and Property values can no longer be modified.
 */
template <typename InterfaceType>
class GenericPropertyObjectPtr : public daq::ObjectPtr<InterfaceType>
{
public:
    using daq::ObjectPtr<InterfaceType>::ObjectPtr;
    //using daq::ObjectPtr<InterfaceType>::operator=;



    GenericPropertyObjectPtr()
        : daq::ObjectPtr<InterfaceType>()

    {
    }

    GenericPropertyObjectPtr(daq::ObjectPtr<InterfaceType>&& ptr)
        : daq::ObjectPtr<InterfaceType>(std::move(ptr))

    {
    }

    GenericPropertyObjectPtr(const daq::ObjectPtr<InterfaceType>& ptr)
        : daq::ObjectPtr<InterfaceType>(ptr)

    {
    }

    GenericPropertyObjectPtr(const PropertyObjectPtr& other)
        : daq::ObjectPtr<InterfaceType>(other)

    {
    }

    GenericPropertyObjectPtr(PropertyObjectPtr&& other) noexcept
        : daq::ObjectPtr<InterfaceType>(std::move(other))

    {
    }
    
    GenericPropertyObjectPtr& operator=(const PropertyObjectPtr& other)
    {
        if (this == &other)
            return *this;

        daq::ObjectPtr<InterfaceType>::operator =(other);


        return *this;
    }

    GenericPropertyObjectPtr& operator=(PropertyObjectPtr&& other) noexcept
    {
        if (this == std::addressof(other))
        {
            return *this;
        }


        daq::ObjectPtr<InterfaceType>::operator =(std::move(other));

        return *this;
    }


    /*!
     * @brief Gets the name of the class the Property object was constructed with.

     * @returns The class's name. Contains an empty string if the class name is not configured.
     * A Property object inherits all properties of the Property object class of the same name. Such Property objects
     * have access to the Type manager from which they can retrieve its class type and its properties.
     */
    daq::StringPtr getClassName() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::StringPtr className;
        auto errCode = this->object->getClassName(&className);
        daq::checkErrorInfo(errCode);

        return className;
    }


    /*!
     * @brief Sets the value of the Property with the given name.

     * @param propertyName The name of the Property.
     * @param value The Property value to be set. Cannot be null.
     * @throws NotFoundException if a property with given `propertyName` is not part of the Property object.
     * @throws CqdaqErrException if the property is Read-only.
     * @throws ConversionFailedException if the `value` cannot be converted to the Value type of the Property.
     * @throws InvalidTypeException if the `value` is a list/dictionary/object with invalid keys/items/fields.
     * @throws ValidateFailedException if the Validator fails to validate the `value`.
     * @throws CqdaqErrException if the Coercer fails to coerce the `value`.
     * @throws FrozenException if the Property object is frozen.
     * @throws CqdaqErrException if the `value` is the same as the default, or the previously written value.
     * Stores the provided `value` into an internal dictionary of property name and value pairs. This property value can
     * later be retrieved through the corresponding getter method when invoked with the same `propertyName`. The provided
     * `value` must adhere to the restrictions of the corresponding Property (that bears the name `propertyName`). If such
     * a Property is part of the Property object, the setter call will fail. Some restrictions include:
     * - The core type of the value must match that of the Property Value type.
     * - If the Property is a numeric type, the value must be equal or greater than the Min value, and equal or smaller
     * than the Max value.
     * - If the Property is Read-only, the setter will fail.
     * - The value will be validated by the Property validator causing the setter method to fail if validation is unsuccessful.
     * - The value will be coerced to fit the coercion expression of the Property coercer before being written into the local
     * dictionary of property values.
     * Setting the value of a Property will override either its default value or the value that was set beforehand.
     * @subsection patterns Behaviour patterns of note
     * - When setting the value of a Property with the Selection values field configured (a Selection property), the `value`
     * must be an integer type, and acts as an index/key into the list/dictionary of Selection values.
     * - If the Property is a Reference property (the Referenced property field is configured), the `value` is actually written
     * under the key of the referenced Property, not the one specified through the `propertyName` argument.
     * - When setting a list or dictionary type property, the list items and dictionary keys and items must be homogeneous, and
     * of the same type as specified by the item and key type of the Property.
     * - Setting a Property value will invoke the corresponding `onPropertyValueWrite` event.
     * @subsection value_set_child_property_objects Child Property objects
     * The Property value setter allows for direct configuration of any child Property objects. To set the Property value of a
     * child Property object, the `propertyName` parameter should be of the format: "childName.propertyName". This pattern
     * can also be used to access nested properties - for example "childName1.childName2.childName3.propertyName".
     */
    void setPropertyValue(const daq::StringPtr& propertyName, const daq::BaseObjectPtr& value) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        auto errCode = this->object->setPropertyValue(propertyName, value);
        daq::checkErrorInfo(errCode);
    }


    /*!
     * @brief Gets the value of the Property with the given name.

     * @param propertyName The name of the Property.
     * @returns The returned Property value.
     * @throws NotFoundException if a property with given `propertyName` is not part of the Property object.
     * @throws InvalidParameterException if attempting to get a value at an index of a non-list Property.
     * @throws OutOfRangeException if attempting to get a value of a list Property at an out-of-bounds index.
     * The value is retrieved from a local dictionary of Property values where they are stored when set. If a a value is not
     * present under the `propertyName` key, the default value of the corresponding Property is returned. If said property
     * is not part of the Property object, an error occurs.
     * @subsection value_get_child_property_objects Child Property objects
     * The Property value getter allows for direct retrieval of values of child Property objects. To get the Property value of a
     * child Property object, the `propertyName` parameter should be of the format: "childName.propertyName". This pattern can
     * also be used to access nested properties - for example "childName1.childName2.childName3.propertyName".
     * @subsection value_get_list_properties List properties
     * If the requested Property is a list-type object, an item of the list at a selected index can be retrieved instead of the list
     * itself. To do so, add a [index] suffix to the `propertyName` parameter. For example "ListProperty[1]" retrieves the 2nd item
     * stored in the list Property value of the Property named "ListProperty".
     * @subsection value_get_selection_properties Selection properties
     * If the requested Property has the Selection values fields configured, the Property value getter returns an index/key of the
     * selected item in the Selection values list/dictionary.
     */
    daq::BaseObjectPtr getPropertyValue(const daq::StringPtr& propertyName) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::BaseObjectPtr value;
        auto errCode = this->object->getPropertyValue(propertyName, &value);
        daq::checkErrorInfo(errCode);

        return value;
    }


    /*!
     * @brief Gets the selected value of the Property, if the Property is a Selection property.

     * @param propertyName The name of the Property.
     * @returns The selected value.
     * @throws NotFoundException if a Property with given `propertyName` is not part of the Property object.
     * @throws InvalidPropertyException if the Property either has no Selection values, or the Selection values are not a list or dictionary.
     * @throws InvalidTypeException if the retrieved value does not match the Property's item type.
     * This function serves as a shortcut to obtaining the Property value of a Property, and using it to retrieve the currently
     * selected value from the Selection values of the Property. For example, if the Selection values contain the following list
     * "["banana", "apple", "pear"]", and the corresponding Property value is set to 1, retrieving the Property selection value
     * will return the string "apple".
     */
    daq::BaseObjectPtr getPropertySelectionValue(const daq::StringPtr& propertyName) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::BaseObjectPtr value;
        auto errCode = this->object->getPropertySelectionValue(propertyName, &value);
        daq::checkErrorInfo(errCode);

        return value;
    }


    /*!
     * @brief Clears the Property value from the Property object

     * @param propertyName The name of the Property of which value should be cleared.
     * @throws NotFoundException if a Property with given `propertyName` is not part of the Property object.
     * @throws FrozenException if the Property object is frozen.
     * When a Property value is set, the value is written in the internal dictionary of Property values.
     * This function will remove said value from the dictionary. If the tries to obtain the Property value of
     * a property that does not have a set Property value, then the default value is returned.
     * Importantly, clearing the value of an Object-type property will release the reference of the current
     * Property object value of the property. It will then create a new clone of the Default value and set it
     * as the value of the property.
     */
    void clearPropertyValue(const daq::StringPtr& propertyName) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        auto errCode = this->object->clearPropertyValue(propertyName);
        daq::checkErrorInfo(errCode);
    }


    /*!
     * @brief Checks if the Property object contains a property named `propertyName`.

     * @param propertyName The name of the property.
     * @returns True if the Property object contains the Property; false otherwise.
     */
    daq::Bool hasProperty(const daq::StringPtr& propertyName) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::Bool hasProperty;
        auto errCode = this->object->hasProperty(propertyName, &hasProperty);
        daq::checkErrorInfo(errCode);

        return hasProperty;
    }


    /*!
     * @brief Gets the Property with the given `propertyName`.

     * @param propertyName The name of the property.
     * @returns The retrieved Property.
     * @throws NotFoundException if the Property object does not contain the requested Property.
     * The property is obtained from either the Property object class of the Property object, or the
     * object's local list of properties. The Property held by the object/class is not returned directly,
     * but is instead cloned, and bound to the Property object. This allows for evaluation of Property metadata
     * that depends on other properties of the Property object.
     * For example, a Property's visibility might depend on the value of another Property. To make evaluation
     * of the visibility parameter possible, the Property must be able to access its owning Property object.
     * Likewise, Reference properties always point at another Property of a Property object. Again, for this to
     * be possible, the Property must be able to access its owning Property object, to be able to retrieve its
     * referenced Property.
     */
    daq::PropertyPtr getProperty(const daq::StringPtr& propertyName) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::PropertyPtr property;
        auto errCode = this->object->getProperty(propertyName, &property);
        daq::checkErrorInfo(errCode);

        return property;
    }


    /*!
     * @brief Adds the property to the Property object.

     * @param property The property to be added.
     * @throws InvalidValueException if the property has no name.
     * @throws AlreadyExistsException if a property with the same name is already part of the Property object.
     * @throws FrozenException if the Property object is frozen.
     * The Property is frozen once added to the Property object, making it immutable. The same Property cannot
     * be added to multiple different Property objects.
     */
    void addProperty(const daq::PropertyPtr& property) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        auto errCode = this->object->addProperty(property);
        daq::checkErrorInfo(errCode);
    }


    /*!
     * @brief Removes the Property named `propertyName` from the Property object.

     * @param propertyName The name of the Property to be removed.
     * @throws NotFoundException if the Property object does not contain a Property named `propertyName`, or the     * Property is part of the Property object's Property object class.
     * @throws FrozenException if the Property object is frozen.
     * A property can only be removed from a Property object, if it was added to the object, and not inherited from its class.
     */
    void removeProperty(const daq::StringPtr& propertyName) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        auto errCode = this->object->removeProperty(propertyName);
        daq::checkErrorInfo(errCode);
    }


    /*!
     * @brief Gets the Event that is triggered whenever a Property value is written to the Property named `propertyName`.

     * @param propertyName The name of the property.
     * @returns The write Event.
     * @throws NotFoundException if the Property object does not contain a Property named `propertyName`.
     * A handler can be added to the event containing a callback function which is invoked whenever the event is triggered.
     * The callback function requires two parameters - a Property object, as well as a "Property value event args" object.
     * The callback will be invoked with the Property object holding the written-to property as the first argument The second argument
     * holds an event args object that contains the written value, event type (Update), and a method of overriding the written value.
     * If the written value is overridden, the overridden value is stored in the Property object instead.
     */
    daq::Event<daq::PropertyObjectPtr, daq::PropertyValueEventArgsPtr> getOnPropertyValueWrite(const daq::StringPtr& propertyName) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        EventPtr<> event;
        auto errCode = this->object->getOnPropertyValueWrite(propertyName, &event);
        daq::checkErrorInfo(errCode);

        return daq::Event<daq::PropertyObjectPtr, daq::PropertyValueEventArgsPtr>(event);
    }


    /*!
     * @brief Gets the Event that is triggered whenever a Property value of a Property named `propertyName` is read.

     * @param propertyName The name of the property.
     * @returns The read Event.
     * @throws NotFoundException if the Property object does not contain a Property named `propertyName`.
     * A handler can be added to the event containing a callback function which is invoked whenever the event is triggered.
     * The callback function requires two parameters - a Property object, as well as a "Property value event args" object.
     * The callback will be invoked with the Property object holding the read value as the first argument. The second argument
     * holds an event args object that contains the read Property value, event type (Read), and a method of overriding the read value.
     * If the read value is overridden, the overridden value is read instead.
     */
    daq::Event<daq::PropertyObjectPtr, daq::PropertyValueEventArgsPtr> getOnPropertyValueRead(const daq::StringPtr& propertyName) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        EventPtr<> event;
        auto errCode = this->object->getOnPropertyValueRead(propertyName, &event);
        daq::checkErrorInfo(errCode);

        return daq::Event<daq::PropertyObjectPtr, daq::PropertyValueEventArgsPtr>(event);
    }


    /*!
     * @brief Returns a list of visible properties contained in the Property object.

     * @returns The List of properties.
     * A Property is visible if both the Visible parameter is set to `true`, and IsReferenced is `false`. The properties
     * are sorted in insertion order unless a custom order is specified.
     * This function returns both the properties added to the Property object, as well as those of its class.
     */
    daq::ListPtr<daq::IProperty> getVisibleProperties() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::ListPtr<daq::IProperty> properties;
        auto errCode = this->object->getVisibleProperties(&properties);
        daq::checkErrorInfo(errCode);

        return properties;
    }


    /*!
     * @brief Returns a list of all properties contained in the Property object.

     * @returns The List of properties.
     * Properties are retrieved regardless of their visibility. They are sorted in insertion order unless a custom order is specified.
     * This function returns both the properties added to the Property object, as well as those of its class.
     */
    daq::ListPtr<daq::IProperty> getAllProperties() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        daq::ListPtr<daq::IProperty> properties;
        auto errCode = this->object->getAllProperties(&properties);
        daq::checkErrorInfo(errCode);

        return properties;
    }


    /*!
     * @brief Sets a custom order of properties as defined in the list of property names.

     * @param orderedPropertyNames A list of names of properties. The order of the list is applied to the object's properties.
     * @throws FrozenException if the Property object is frozen.
     * The list should contain names of properties available in the object. When retrieving the Property object's properties, they will
     * be sorted in the order in which the names appear in the provided list. Any properties not in the custom order are
     * kept in insertion order at the end of the Property object's list of properties.
     */
    void setPropertyOrder(const daq::ListPtr<daq::IString>& orderedPropertyNames) const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        auto errCode = this->object->setPropertyOrder(orderedPropertyNames);
        daq::checkErrorInfo(errCode);
    }


    /*!
     * @brief Begins batch configuration of the object.

     * Batched configuration is used to apply several settings at once. To begin batch configuration, call `beginUpdate`.
     * When the `setPropertyValue` is called on the object, the changes are not immediately applied to it. When `endUpdate`
     * is called, the property values set between the `beginUpdate` and `endUpdate` method calls are
     * applied. It triggers the ˙OnPropertyWriteEvent` for each property value set, and the `OnEndUpdate` event.
     * `beginUpdate` is called recursively for each child property object.
     */
    void beginUpdate() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        auto errCode = this->object->beginUpdate();
        daq::checkErrorInfo(errCode);
    }


    /*!
     * @brief Ends batch configuration of the object.

     * Batched configuration is used to apply several settings at once. To begin batch configuration, call `beginUpdate`.
     * When the `setPropertyValue` is called on the object, the changes are not immediately applied to it. When `endUpdate`
     * is called, the property values set between the `beginUpdate` and `endUpdate` method calls are
     * applied. It triggers the ˙OnPropertyWriteEvent` for each property value set, and the `OnEndUpdate` event.
     * `endUpdate` is called recursively for each child property object.
     */
    void endUpdate() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        auto errCode = this->object->endUpdate();
        daq::checkErrorInfo(errCode);
    }


    /*!
     * @brief Gets the Event that is triggered whenever the batch configuration is applied.

     * @returns The Event.
     * A handler can be added to the event containing a callback function which is invoked whenever the event is triggered.
     * The callback function requires one parameter - a "End update value event args" object.
     * The callback will be invoked with the batch configuration is applied, i.e. from the `endUpdate` method. The first argument
     * holds an event args object that contains a list of properties updated.
     */
    daq::Event<daq::PropertyObjectPtr, daq::EndUpdateEventArgsPtr> getOnEndUpdate() const
    {
        if (this->object == nullptr)
            throw daq::InvalidParameterException();

        EventPtr<> event;
        auto errCode = this->object->getOnEndUpdate(&event);
        daq::checkErrorInfo(errCode);

        return daq::Event<daq::PropertyObjectPtr, daq::EndUpdateEventArgsPtr>(event);
    }

#if __has_include(<coreobjects/property_object_ptr.custom.h>)
    #include <coreobjects/property_object_ptr.custom.h>
#endif
};

/*!
 * @}
 */


/*!
 * @addtogroup objects_property_object_obj_factories Factories
 * @{

 */


/*!
 * @}
 */


END_NAMESPACE_CQDAQ
